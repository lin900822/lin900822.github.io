[{"content":" 前言 # Docker Compose # services: gitlab: image: gitlab/gitlab-ce:latest container_name: gitlab restart: always environment: GITLAB_OMNIBUS_CONFIG: | # 讓網頁上的 Clone 連結的ip顯示正確 external_url \u0026#39;http://\u0026lt;區網ip\u0026gt;:12080\u0026#39; nginx[\u0026#39;listen_port\u0026#39;] = 80 nginx[\u0026#39;listen_https\u0026#39;] = false # 讓網頁上的 Clone 連結的ssh port顯示正確 gitlab_rails[\u0026#39;gitlab_shell_ssh_port\u0026#39;] = 12022 prometheus_monitoring[\u0026#39;enable\u0026#39;] = false ports: - \u0026#34;12080:80\u0026#34; - \u0026#34;12443:443\u0026#34; - \u0026#34;12022:22\u0026#34; # ssh改12022，避免衝突 volumes: - /path/to/your/volume/gitlab/gitlab-config:/etc/gitlab - /path/to/your/volume/gitlab/gitlab-logs:/var/log/gitlab - /path/to/your/volume/gitlab/gitlab-data:/var/opt/gitlab shm_size: \u0026#39;256m\u0026#39; networks: - gitlab-network gitlab-runner: image: gitlab/gitlab-runner:latest container_name: gitlab-runner restart: always depends_on: - gitlab volumes: - /path/to/your/volume/gitlab/gitlab-runner-config:/etc/gitlab-runner - /var/run/docker.sock:/var/run/docker.sock networks: - gitlab-network networks: gitlab-network: driver: bridge 預設創建了root帳號，預設密碼可以用以下指令查詢\nsudo docker exec -it gitlab grep \u0026#39;Password:\u0026#39; /etc/gitlab/initial_root_password 註冊 Runner # 取得Gitlab Runner Token # 打開Gitlab網頁，登入管理員帳號，進入 Admin Area \u0026gt; CI/CD \u0026gt; Runners \u0026gt; Create instance runner\nTags輸入docker然後就可以Create runner\n就會跳轉到下一個頁面，裡面就有一個Token，把它複製起來\n設定 gitlab-runner # docker exec -it gitlab-runner gitlab-runner register 進入互動問答：\nGitLab instance URL：按照上面設置填入Gitlab Server的URL即可(port也要對，這邊是12080) Registration token：剛剛透過Gitlab Admin網頁產生的token Executor：選擇docker Tags：docker Default Docker Image：docker:stable 修改 Runner 設定以支援Docker-out-of-Docker (DooD) # 編輯宿主機上的/path/to/your/volume/gitlab/gitlab-runner-config/config.toml\n[[runners]] # ... 其他設定 ... executor = \u0026#34;docker\u0026#34; [runners.docker] tls_verify = false image = \u0026#34;docker:stable\u0026#34; privileged = true # 【重要】改成 true disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false # 【重要】掛載 socket，讓 Job 容器也能呼叫宿主機 Docker volumes = [\u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34;, \u0026#34;/cache\u0026#34;] 然後\ndocker restart gitlab-runner 設定完後回到gitlab網頁中應該就可以看到燈號變成綠色的了\n最終效果 # ","date":"19 December 2025","externalUrl":null,"permalink":"/posts/devops/gitlab-cicd/","section":"Posts","summary":"","title":"[DevOps] 自架Gitlab以及Gitlab Runner跑CI/CD","type":"posts"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/","section":"Wilson Lin's Blog","summary":"","title":"Wilson Lin's Blog","type":"page"},{"content":" 前言 # Linux Kernel中的Process, Thread其實跟我們一般認知的定義有些不太一樣，因此這篇文章來記錄這些名詞上的差異。\n歷史 # 最開始的Linux，並沒有follow POSIX的標準，且當初也沒有針對多執行緒去設計架構，都還是以單執行緒為主，因此最早期設計了task_struct這個資料結構當作Scheduler調度CPU資源的單位，一個task_struct就代表一個Process。\n後來的設計 # 後來多核CPU逐漸成為主流後，多執行緒的設計就很有必要了，但Linux為了方便便延續了之前的設計，將task_struct定義改為Lightweight Process(LWP)，其實就是我們一般認知的Thread的概念，而Process這個名詞則變成了一組LWP的集合，Linux稱之為Thread Group。\ntask_struct # task_struct又被稱作Process descriptor(也就是OS中的PCB)，存放所有跟該LWP有關的資料，其中有兩個重要的欄位：\npid ：這個LWP的Id，所有LWP的Id都是唯一的 tgid：同一組LWP(Thread)形成的Process的Id，如果是main thread(或稱Thread Group Leader)則跟pid一致，如果是其他thread則會記錄main thread的pid // task_struct中的欄位 pid_t pid; pid_t tgid; 以及另外兩個重要的function：\ngetpid()：回傳tgid欄位 gettid()：回傳pid 欄位，也就是說pid其實實際上的意義是Thread Id，但task_struct中並沒有一個專屬的欄位紀錄tid，而是統一用pid ","date":"10 December 2025","externalUrl":null,"permalink":"/posts/linux/linux-kernel-process-and-thread/","section":"Posts","summary":"","title":"【Linux Kernel】Process and Thread的關係","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]